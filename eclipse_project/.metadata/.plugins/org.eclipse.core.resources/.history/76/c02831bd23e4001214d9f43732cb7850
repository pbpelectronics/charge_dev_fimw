#include "stm32f10x.h"
#include "stm32f10x_conf.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_dma.h"
#include "stm32f10x_adc.h"
#include "misc.h"

#include "nokia1100_lcd_lib.h"
#include "display/images_printing.h"

#include "stdio.h"
#include "stdlib.h"

//SystemCoreClock=(uint32_t)8000000;
uint64_t time_ms;
int bufer[15];

//глобальные переменные
#define ADC_CH 8  //количество каналов
#define OVER_SAMPL 32 //количество семплов для усреднения
uint32_t ADC_SUM[ADC_CH]; //буффер для суммирования
uint16_t curr_sample; //считаем количество семлов
uint16_t AI[ADC_CH], ADC_VAL[ADC_CH]; //АI- финальный буфер, ADC_VAL- в нее пишем DMA

void Int2Str(char *pStr, unsigned int value, int charCount) {

	// this implements sprintf(strVal, "%d", temp); faster
	// note that this is just for values >= 0, while sprintf covers negative values.
	// this also does not check if the pStr pointer points to a valid allocated space.
	// caller should make sure it is allocated.
	// point to the end of the array
	pStr = pStr + (charCount - 1);

	// convert the value to string starting from the ones, then tens, then hundreds etc...
	do {
		*pStr-- = (value % 10) + '0';
		value /= 10;
	} while (charCount--);
}

void TIM2_IRQHandler() {
	time_ms++;
	char str[10];

	Int2Str(str, time_ms, 10);
	nlcd_Print(str);
}

void init_timer_counter2() {
	TIM_TimeBaseInitTypeDef timer2;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseStructInit(&timer2);
	timer2.TIM_Prescaler = 800;
	timer2.TIM_Period = 10;
	TIM_TimeBaseInit(TIM2, &timer2);
	TIM_Cmd(TIM2, ENABLE);
	NVIC_EnableIRQ(TIM2_IRQn);
}

void initADC() {
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitStructure.GPIO_Pin = GPIO_ODR_ODR0 | GPIO_ODR_ODR1 | GPIO_ODR_ODR2
			| GPIO_ODR_ODR3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	ADC_InitTypeDef ADC_InitStructure;
	ADC_InitStructure.ADC_Mode = ADC_Mode_InjecSimult;
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfChannel = 4; //We using 8 channels

	ADC_Init(ADC1, &ADC_InitStructure); //Initialise ADC1

	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_1, 1,
			ADC_SampleTime_1Cycles5 );
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_2, 2,
			ADC_SampleTime_1Cycles5 );
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_3, 3,
			ADC_SampleTime_1Cycles5 );
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_4, 4,
			ADC_SampleTime_1Cycles5 );

	ADC_Cmd(ADC1, ENABLE); //Enable ADC1

	//Enable ADC1 reset calibration register
	ADC_ResetCalibration(ADC1 );
	while (ADC_GetResetCalibrationStatus(ADC1 )) {
		NOP(); //Check the end of ADC1 reset calibration register
	}

	//Start ADC1 calibration
	ADC_StartCalibration(ADC1 );
	while (ADC_GetCalibrationStatus(ADC1 )) {
		NOP(); //Check the end of ADC1 calibration
	}

}

int main(void) {
//	__enable_irq();
	nlcd_Init();
//	init_timer_counter2();

//	nlcd_Print("test");
	bootMessage();
//	Delay(0x1ffff);
//	nlcd_Clear();
//	printMainImageTemplate();
//	printDigitals(1,12.3);
	while (1) {
//		for (unsigned char i = 0; i<6; i++)
//			printBattaryImage(i);
	}
	return 0;
}
