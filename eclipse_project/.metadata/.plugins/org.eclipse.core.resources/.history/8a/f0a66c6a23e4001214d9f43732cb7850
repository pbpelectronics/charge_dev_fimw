#include "stm32f10x.h"
#include "stm32f10x_conf.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_dma.h"
#include "stm32f10x_adc.h"
#include "misc.h"

#include "nokia1100_lcd_lib.h"
#include "display/images_printing.h"

#include "stdio.h"
#include "stdlib.h"

//SystemCoreClock=(uint32_t)8000000;
uint64_t time_ms;
int bufer[15];

//глобальные переменные
#define ADC_CH 8  //количество каналов
#define OVER_SAMPL 32 //количество семплов для усреднения
uint32_t ADC_SUM[ADC_CH]; //буффер для суммирования
uint16_t curr_sample; //считаем количество семлов
uint16_t AI[ADC_CH], ADC_VAL[ADC_CH]; //АI- финальный буфер, ADC_VAL- в нее пишем DMA

void Int2Str(char *pStr, unsigned int value, int charCount) {

	// this implements sprintf(strVal, "%d", temp); faster
	// note that this is just for values >= 0, while sprintf covers negative values.
	// this also does not check if the pStr pointer points to a valid allocated space.
	// caller should make sure it is allocated.
	// point to the end of the array
	pStr = pStr + (charCount - 1);

	// convert the value to string starting from the ones, then tens, then hundreds etc...
	do {
		*pStr-- = (value % 10) + '0';
		value /= 10;
	} while (charCount--);
}

void TIM2_IRQHandler() {
	time_ms++;
	char str[10];

	Int2Str(str, time_ms, 10);
	nlcd_Print(str);
}

void init_timer_counter2() {
	TIM_TimeBaseInitTypeDef timer2;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseStructInit(&timer2);
	timer2.TIM_Prescaler = 800;
	timer2.TIM_Period = 10;
	TIM_TimeBaseInit(TIM2, &timer2);
	TIM_Cmd(TIM2, ENABLE);
	NVIC_EnableIRQ(TIM2_IRQn);
}

void Setup_ADC1(void) {

	DMA_InitTypeDef DMA_InitStructure; //Variable used to setup the DMA

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	//--Enable DMA1 clock--
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
	//==Configure DMA1 - Channel1==
	DMA_DeInit(DMA1_Channel1 ); //Set DMA registers to default values
	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1 ->DR; //Address of peripheral the DMA must map to
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) &ADC_VAL; //Variable to which ADC values will be stored
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
	DMA_InitStructure.DMA_BufferSize = ADC_CH; //Buffer size (8 because we using 8 channels)
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;

	//Настройка Прерывание -по окончании трансфера

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	DMA_ITConfig(DMA1_Channel1, DMA1_IT_TC1, ENABLE);
	DMA_Init(DMA1_Channel1, &DMA_InitStructure); //Initialise the DMA

}

void initADC() {
	ADC_InitTypeDef ADC_InitStructure;
	ADC_InitStructure.ADC_Mode = ADC_Mode_InjecSimult;
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfChannel = 4; //We using 8 channels

	ADC_Init(ADC1, &ADC_InitStructure); //Initialise ADC1

	//Порядок оцифровки

#define ADC_SampleTime ADC_SampleTime_239Cycles5
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_1, 1, ADC_SampleTime_1Cycles5);
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_2, 2, ADC_SampleTime_1Cycles5);
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_3, 3, ADC_SampleTime_1Cycles5);
	ADC_InjectedChannelConfig(ADC1, ADC_InjectedChannel_4, 4, ADC_SampleTime_1Cycles5);

	ADC_DMACmd(ADC1, ENABLE); //Enable ADC1 DMA
	ADC_Cmd(ADC1, ENABLE); //Enable ADC1

	//Калибровка ADC1

	//Enable ADC1 reset calibration register
	ADC_ResetCalibration(ADC1 );
	while (ADC_GetResetCalibrationStatus(ADC1 ))
		; //Check the end of ADC1 reset calibration register

	//Start ADC1 calibration
	ADC_StartCalibration(ADC1 );
	while (ADC_GetCalibrationStatus(ADC1 ))
		; //Check the end of ADC1 calibration

}

int main(void) {
//	__enable_irq();
	nlcd_Init();
//	init_timer_counter2();

//	nlcd_Print("test");
	bootMessage();
//	Delay(0x1ffff);
//	nlcd_Clear();
//	printMainImageTemplate();
//	printDigitals(1,12.3);
	while (1) {
//		for (unsigned char i = 0; i<6; i++)
//			printBattaryImage(i);
	}
	return 0;
}
